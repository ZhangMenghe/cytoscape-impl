package org.cytoscape.task.internal.export;


import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;

import org.cytoscape.io.CyFileFilter;
import org.cytoscape.io.write.CyWriterManager;
import org.cytoscape.io.write.CyWriterFactory;
import org.cytoscape.work.Tunable;
import org.cytoscape.work.TunableValidator;
import org.cytoscape.work.util.ListSingleSelection;


/**
 * An abstract utility implementation of a Task that writes a user defined 
 * file to a file type determined by a provided writer manager.  This class
 * is meant to be extended for specific file types such that the appropriate
 * {@link org.cytoscape.io.write.CyWriter} can be identified.
 */
public abstract class TunableAbstractCyWriter<S extends CyWriterFactory,T extends CyWriterManager<S>> extends AbstractCyWriter<S,T> implements
		TunableValidator {

	/**
	 * The list of file type options generated by the file types
	 * available from the CyWriterManager.  This field should not
	 * be set directly, but rather handled by the {@link org.cytoscape.work.Tunable}
	 * processing.
	 */
	@Tunable(description = "Select the export file format")
	public ListSingleSelection<String> options;

	protected final String getExportFileFormat() {
		return options.getSelectedValue();
	}

	/**
	 * @param writerManager The CyWriterManager to be used to determine which
	 * {@link org.cytoscape.io.write.CyWriter} to be used to write the file chosen by the user. 
	 */
	public TunableAbstractCyWriter(T writerManager) {
		super(writerManager);
		options = new ListSingleSelection<String>(new ArrayList<String>(descriptionFilterMap.keySet()));
	}

	@Override
	public final ValidationState getValidationState(final Appendable msg) {
		// Make sure we have the right extension, if not, then force it:
		if (!fileExtensionIsOk(outputFile))
			outputFile = addOrReplaceExtension(outputFile);

		if (outputFile.exists()) {
			try {
				msg.append("File already exists, are you sure you want to overwrite it?");
			} catch (final Exception e) {
				/* Intentionally empty! */
			}
			return ValidationState.REQUEST_CONFIRMATION;
		} else
			return ValidationState.OK;
	}

	protected final boolean fileExtensionIsOk(final File file) {
		final String exportFileFormat = getExportFileFormat();
		if (exportFileFormat == null)
			return true;

		final CyFileFilter filter = descriptionFilterMap.get(exportFileFormat);
		if (filter == null)
			return true;

		final String extension = getExtension(file.getPath());
		if (extension == null)
			return false;

		return filter.getExtensions().contains(extension);
	}

	private static final String getExtension(final String fileName) {
		final int lastDotPos = fileName.lastIndexOf('.');
		if (lastDotPos == -1 || lastDotPos == fileName.length() - 1)
			return null;
		return fileName.substring(lastDotPos + 1).toLowerCase();
	}

	protected final File addOrReplaceExtension(final File file) {
		final CyFileFilter filter = descriptionFilterMap.get(getExportFileFormat());
		if (filter == null)
			return file;

		final Iterator<String> extensions = filter.getExtensions().iterator();
		if (!extensions.hasNext())
			return file;

		final String extension = extensions.next();
		final String pathWithoutExtension = stripExtension(file.getPath());

		return new File(pathWithoutExtension + "." + extension);
	}

	private static String stripExtension(final String fileName) {
		final String extension = getExtension(fileName);
		if (extension == null)
			return fileName;

		return fileName.substring(0, fileName.length() - 1 - extension.length());
	}
}
