package org.cytoscape.app.internal.ui;

import java.awt.Component;
import java.awt.Container;
import java.awt.Desktop;
import java.awt.Font;
import java.awt.event.ComponentEvent;
import java.awt.event.ComponentListener;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.net.URISyntaxException;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.JTree;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.event.HyperlinkEvent;
import javax.swing.event.HyperlinkEvent.EventType;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import javax.swing.event.HyperlinkListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.text.html.HTMLDocument;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;

import org.cytoscape.app.internal.exception.AppDownloadException;
import org.cytoscape.app.internal.exception.AppInstallException;
import org.cytoscape.app.internal.exception.AppParsingException;
import org.cytoscape.app.internal.manager.App;
import org.cytoscape.app.internal.manager.AppManager;
import org.cytoscape.app.internal.manager.AppParser;
import org.cytoscape.app.internal.net.ResultsFilterer;
import org.cytoscape.app.internal.net.WebApp;
import org.cytoscape.app.internal.net.WebQuerier;
import org.cytoscape.app.internal.util.DebugHelper;
import org.cytoscape.util.swing.FileChooserFilter;
import org.cytoscape.util.swing.FileUtil;
import org.cytoscape.work.Task;
import org.cytoscape.work.TaskIterator;
import org.cytoscape.work.TaskManager;
import org.cytoscape.work.TaskMonitor;

/**
 * This class represents the panel in the App Manager dialog's tab used for installing new apps.
 * Its UI setup code is generated by the Netbeans 7 GUI builder.
 */
public class InstallFromStorePanel extends javax.swing.JPanel {
	
	/** Long serial version identifier required by the Serializable class */
	private static final long serialVersionUID = -1208176142084829272L;
	
    private javax.swing.JScrollPane descriptionScrollPane;
    private javax.swing.JTextPane descriptionTextPane;
    private javax.swing.JTextField filterTextField;
    private javax.swing.JButton installSelectedButton;
    private javax.swing.JButton jButton1;
    private javax.swing.JScrollPane resultsScrollPane;
    private javax.swing.JSplitPane resultsSplitPane;
    private javax.swing.JTree resultsTree;
    private javax.swing.JLabel searchAppsLabel;
    private javax.swing.JCheckBox showCompatibleCheckBox;
	
	private JFileChooser fileChooser;
	
	private AppManager appManager;
	private FileUtil fileUtil;
	private TaskManager taskManager;
	private Container parent;
	
    public InstallFromStorePanel(final AppManager appManager, FileUtil fileUtil, TaskManager taskManager, Container parent) {
        this.appManager = appManager;
        this.fileUtil = fileUtil;
        this.taskManager = taskManager;
        this.parent = parent;
    	initComponents();
        
		taskManager.execute(new TaskIterator(new Task() {
			
			// Obtain information for all available apps, then append tag information
			@Override
			public void run(TaskMonitor taskMonitor) throws Exception {
				taskMonitor.setTitle("Obtaining Apps from App Store");
				
				WebQuerier webQuerier = appManager.getWebQuerier();
		    	
				taskMonitor.setStatusMessage("Getting available apps");
				Set<WebApp> availableApps = webQuerier.getAllApps();
				
				// Note: Code below not used because web store now returns tag information when
				// returning all apps
				
				/* 
		    	// Obtain available tags
		    	Set<WebQuerier.AppTag> availableTags = webQuerier.getAllTags();
		    	
		    	double progress = 0;
		    	
		    	for (WebQuerier.AppTag appTag : availableTags) {

		    		taskMonitor.setStatusMessage("Getting apps for tag: " + appTag.getFullName());
		    		progress += 1.0 / availableTags.size();
		    		taskMonitor.setProgress(progress);
		    		
		    		// Obtain apps for the current tag
		    		Set<WebApp> tagApps = webQuerier.getAppsByTag(appTag.getName());
		    		
		    		// Assume the set of apps returned is a subset of all available apps
		    		for (WebApp tagApp : tagApps) {
		    			tagApp.getAppTags().add(appTag);
		    		}
		    	}
				*/
				
				// Once the information is obtained, update the tree
				SwingUtilities.invokeLater(new Runnable() {

					@Override
					public void run() {
						populateTree(appManager.getWebQuerier().getAllApps());
					}
					
				});
			}

			@Override
			public void cancel() {
			}
			
		}));
    	
		/*
		addTagInformation();
        populateTree(appManager.getWebQuerier().getAllApps());
        */
		
        setupDescriptionListener();
        setupHyperlinkListener();
        setupTextFieldListener();
    }

    private void initComponents() {

        installSelectedButton = new javax.swing.JButton();
        searchAppsLabel = new javax.swing.JLabel();
        resultsSplitPane = new javax.swing.JSplitPane();
        resultsScrollPane = new javax.swing.JScrollPane();
        resultsTree = new javax.swing.JTree();
        descriptionScrollPane = new javax.swing.JScrollPane();
        descriptionTextPane = new javax.swing.JTextPane();
        showCompatibleCheckBox = new javax.swing.JCheckBox();
        jButton1 = new javax.swing.JButton();
        filterTextField = new javax.swing.JTextField();
        
        installSelectedButton.setText("Install Selected");
        installSelectedButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                installSelectedButtonActionPerformed(evt);
            }
        });

        searchAppsLabel.setText("Filter Apps:");

        resultsSplitPane.setDividerLocation(245);

        javax.swing.tree.DefaultMutableTreeNode treeNode1 = new javax.swing.tree.DefaultMutableTreeNode("Available Apps (0)");
        resultsTree.setModel(new javax.swing.tree.DefaultTreeModel(treeNode1));
        resultsScrollPane.setViewportView(resultsTree);

        resultsSplitPane.setLeftComponent(resultsScrollPane);

        descriptionTextPane.setContentType("text/html");
        descriptionTextPane.setEditable(false);
        
        // Make the JTextPane render HTML using the default UI font
        Font font = UIManager.getFont("Label.font");
        String bodyRule = "body { font-family: " + font.getFamily() + "; " +
                "font-size: " + font.getSize() + "pt; }";
        ((HTMLDocument) descriptionTextPane.getDocument()).getStyleSheet().addRule(bodyRule);
        
        descriptionTextPane.setText("<html> <head> </head> <body> <p style=\"margin-top: 0\"> App information is displayed here. <a href=\"http://www.w3schools.com/\">Test link</a>          </p>   </body> </html> ");
        descriptionTextPane.setText("");
        descriptionScrollPane.setViewportView(descriptionTextPane);

        resultsSplitPane.setRightComponent(descriptionScrollPane);

        showCompatibleCheckBox.setText("Show only compatible apps");

        jButton1.setText("Browse File");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
        	public void actionPerformed(java.awt.event.ActionEvent evt) {
        		browseButtonActionPerformed(evt);
        	}
        });

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(layout.createSequentialGroup()
                        .add(resultsSplitPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 534, Short.MAX_VALUE)
                        .addContainerGap())
                    .add(layout.createSequentialGroup()
                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(layout.createSequentialGroup()
                                .add(filterTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 269, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                                .add(showCompatibleCheckBox))
                            .add(layout.createSequentialGroup()
                                .add(installSelectedButton)
                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                                .add(jButton1))
                            .add(searchAppsLabel))
                        .add(0, 0, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .add(searchAppsLabel)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(filterTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(showCompatibleCheckBox))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(resultsSplitPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 321, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE, false)
                    .add(installSelectedButton, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(jButton1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
    }

    private void searchButtonActionPerformed(java.awt.event.ActionEvent evt) {                                             
        // TODO add your handling code here:
    }
    
    private void browseButtonActionPerformed(java.awt.event.ActionEvent evt) {
    	// Setup a the file filter for the open file dialog
    	FileChooserFilter fileChooserFilter = new FileChooserFilter("Jar, Zip Files (*.jar, *.zip)",
    			new String[]{"jar", "zip"});
    	
    	Collection<FileChooserFilter> fileChooserFilters = new LinkedList<FileChooserFilter>();
    	fileChooserFilters.add(fileChooserFilter);
    	
    	// Show the dialog
    	File[] files = fileUtil.getFiles(parent, 
    			"Choose file(s)", FileUtil.LOAD, FileUtil.LAST_DIRECTORY, "Install", true, fileChooserFilters);
    	
        if (files != null) {
        	
        	for (int index = 0; index < files.length; index++) {
        		AppParser appParser = appManager.getAppParser();
        		
        		App app = null;
        		
        		// Attempt to parse each file as an App object
        		try {
					app = appParser.parseApp(files[index]);
					
				} catch (AppParsingException e) {
					
					// TODO: Replace DebugHelper.print() messages with exception or a pop-up message box
					DebugHelper.print("Error parsing app: " + e.getMessage());
					
					JOptionPane.showMessageDialog(parent, "Error opening app: " + e.getMessage(),
		                       "Error", JOptionPane.ERROR_MESSAGE);
				} finally {
					
					// Install the app if parsing was successful
					if (app != null) {
						try {
							appManager.installApp(app);
						} catch (AppInstallException e) {
							JOptionPane.showMessageDialog(parent, "Error installing app: " + e.getMessage(),
				                       "Error", JOptionPane.ERROR_MESSAGE);
						}
					}
				}
        	}
        }
    }
    
    /**
     * Attempts to insert newlines into a given string such that each line has no 
     * more than the specified number of characters.
     */
    private String splitIntoLines(String text, int charsPerLine) {
    	return null;
    }

    private void setupTextFieldListener() {
        filterTextField.getDocument().addDocumentListener(new DocumentListener() {
			
			@Override
			public void removeUpdate(DocumentEvent arg0) {
				// TODO Auto-generated method stub
				filterResults();
			}
			
			@Override
			public void insertUpdate(DocumentEvent arg0) {
				// TODO Auto-generated method stub
				filterResults();
			}
			
			@Override
			public void changedUpdate(DocumentEvent arg0) {
				// TODO Auto-generated method stub
				filterResults();
			}
		});
    }
    
    private void filterResults() {
        String text = filterTextField.getText();
    	
    	Set<WebApp> allApps = appManager.getWebQuerier().getAllApps();
    	
    	if (text != null && text.length() > 0) {
    		ResultsFilterer filterer = new ResultsFilterer();
    		
    		populateTree(filterer.findMatches(text, allApps));
    		
    	} else {
    		populateTree(allApps);
    	}	
    }
    
    private void searchComboBoxPropertyChange(java.beans.PropertyChangeEvent evt) {

    }
    
    private void installSelectedButtonActionPerformed(java.awt.event.ActionEvent evt) {                                                      
        final Set<WebApp> selectedApps = getSelectedApps();
        final WebQuerier webQuerier = appManager.getWebQuerier();
        
        DebugHelper.print("Download path: " + appManager.getDownloadedAppsPath());
		
		taskManager.execute(new TaskIterator(new Task() {

			@Override
			public void run(TaskMonitor taskMonitor) throws Exception {
				taskMonitor.setTitle("Installing App from App Store");
				
				double progress = 0;
				double progressIncrement = 1.0 / selectedApps.size();
				
				for (WebApp webApp : selectedApps) {
					
					taskMonitor.setStatusMessage("Installing app: " + webApp.getFullName());
					
					// Download app
	        		File appFile = webQuerier.downloadApp(webApp.getName(), null, new File(appManager.getDownloadedAppsPath()));
					
	        		if (appFile != null) {
		        		// Parse app
		        		App parsedApp = appManager.getAppParser().parseApp(appFile);
		        		
		        		// Install app
						appManager.installApp(parsedApp);
	        		} else {
	        			// Log error: no download links were found for app
	        			DebugHelper.print("Unable to find download url for: " + webApp.getFullName());
	        		}
	        		
	        		progress += progressIncrement;
	        		taskMonitor.setProgress(progress);
				}
				
				
			}

			@Override
			public void cancel() {
			}
			
		}));
    }
 

    private void resetButtonActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
    }

    private void viewOnWebStoreButtonActionPerformed(java.awt.event.ActionEvent evt) {
        // TODO add your handling code here:
    }
    
    /**
     * Populate the current tree of results with the available apps from the web store.
     */
    private void populateTreeOld() {
    	WebQuerier webQuerier = appManager.getWebQuerier();
    	
    	DefaultMutableTreeNode root = new DefaultMutableTreeNode("Available Apps (" + webQuerier.getAllApps().size() + ")");
    	
    	// Obtain available tags
    	Set<WebQuerier.AppTag> availableTags = webQuerier.getAllTags();
    	
    	for (WebQuerier.AppTag appTag : availableTags) {
    		DefaultMutableTreeNode tagNode = new DefaultMutableTreeNode(appTag.getFullName() + " (" + appTag.getCount() + ")");
    		
    		// Obtain apps for the current tag
    		DebugHelper.print("Getting apps for tag: " + appTag.getName());
    		Set<WebApp> tagApps = webQuerier.getAppsByTag(appTag.getName());
    		
    		for (WebApp tagApp : tagApps) {
    			tagNode.add(new DefaultMutableTreeNode(tagApp));
    		}
    		
    		root.add(tagNode);
    	}
    	
    	resultsTree.setModel(new DefaultTreeModel(root));
    }
    
    // Populate the tree using a given set of WebApp objects.
    private void populateTree(Set<WebApp> webApps) {
    	WebQuerier webQuerier = appManager.getWebQuerier();
    	
    	// Assume given apps have been labelled with tags
    	// Above assumption should be valid once web store is updated to provide tag information when requesting all apps
    	
    	DefaultMutableTreeNode root = new DefaultMutableTreeNode("Matches (" + webApps.size() + ")");
    	
    	// Obtain available tags
    	Set<WebQuerier.AppTag> availableTags = webQuerier.getAllTags();
    	
    	/*
    	// Obtain apps for each tag and add them to the tree
    	for (WebQuerier.AppTag appTag : availableTags) {
    		Set<WebApp> associatedApps = webQuerier.getAppsByTag(appTag.getName());
    		
    		if (associatedApps.size() > 0) {
	    		DefaultMutableTreeNode tagNode = new DefaultMutableTreeNode(appTag.getFullName() + " (" + associatedApps.size() + ")");
	    		
	    		for (WebApp webApp : associatedApps) {
	    			tagNode.add(new DefaultMutableTreeNode(webApp));
	    		}
	    		
    			root.add(tagNode);
    		}
    	}
    	*/
    
    	
    	// Construct a dictionary that maps each tag to a set containing all the apps associated with that tag
    	// in order to produce the tree
    	Map<WebQuerier.AppTag, Set<WebApp>> appsByTag = new HashMap<WebQuerier.AppTag, Set<WebApp>>();
    	for (WebQuerier.AppTag appTag : availableTags) {
    		appsByTag.put(appTag, new HashSet<WebApp>());
    	}
    	
    	for (WebApp webApp : webApps) {
    		// Add the app to the appropriate set(s) in the dictionary
    		for (WebQuerier.AppTag appTag : webApp.getAppTags()) {
    			appsByTag.get(appTag).add(webApp);
    		}
    	}
    	
    	for (Entry<WebQuerier.AppTag, Set<WebApp>> entry : appsByTag.entrySet()) {
    		WebQuerier.AppTag appTag = entry.getKey();
    		Set<WebApp> associatedApps = entry.getValue();
    		
    		if (associatedApps.size() > 0) {
	    		DefaultMutableTreeNode tagNode = new DefaultMutableTreeNode(appTag.getFullName() + " (" + associatedApps.size() + ")");
	    		
	    		for (WebApp webApp : associatedApps) {
	    			DefaultMutableTreeNode appNode = new DefaultMutableTreeNode(webApp);
	    			
	    			tagNode.add(appNode);
	    		}
	    		
    			root.add(tagNode);
    		}
    	}
    	
    	resultsTree.setModel(new DefaultTreeModel(root));
    	
    	for (int index = resultsTree.getRowCount() - 1; index >= 0; index--) {
    		resultsTree.expandRow(index);
    	}
    	
    	/*
    	resultsTree.setCellRenderer(new DefaultTreeCellRenderer() {
			private static final long serialVersionUID = -2593107773334586019L;

			@Override
    		public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel,
    				boolean expanded, boolean leaf, int row, boolean hasFocus) {
					
    			super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);
    			
    			DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
    			
    			if (node.getUserObject() instanceof WebApp) {
    				setIcon(((WebApp) node.getUserObject()).getImageIcon());
    			}
    			
    			return this;
    		}
    	});
    	*/
    	// resultsTree.setRowHeight(0);
    }
    
    /**
     * Obtain the set of {@link WebApp} objects corresponding to currently selected entries in the tree of apps
     * @return A set of {@link WebApp} objects corresponding to selected apps in the tree
     */
    private Set<WebApp> getSelectedApps() {
    	TreePath[] selectedPaths = resultsTree.getSelectionPaths();
    	if (selectedPaths == null) {
    		// Return an empty set if no selections were found
    		return new HashSet<WebApp>();
    	}
    	
    	Set<WebApp> selectedApps = new HashSet<WebApp>();
    	
    	for (int index = 0; index < selectedPaths.length; index++) {
    		TreePath selectedPath = selectedPaths[index];
    		
    		DefaultMutableTreeNode selectedNode = (DefaultMutableTreeNode) selectedPath.getLastPathComponent();
    		Object selectedUserObject = selectedNode.getUserObject();
    		
    		// Selecting tag category nodes are also added to the set of selected paths; avoid
    		// adding them as selected apps by making this check
    		if (selectedUserObject instanceof WebApp) {
    			selectedApps.add((WebApp) selectedUserObject);
    		}
    	}
    	
    	return selectedApps;
    }
    
    /**
     * Setup and register a listener to the tree to listen for selection changed events in order to update the
     * app description box
     */
    private void setupDescriptionListener() {
    	resultsTree.addTreeSelectionListener(new TreeSelectionListener() {
			
			@Override
			public void valueChanged(TreeSelectionEvent event) {
				updateDescriptionBox();
			}
		});
    }
    
    private void setupHyperlinkListener() {
    	descriptionTextPane.addHyperlinkListener(new HyperlinkListener() {
			
			@Override
			public void hyperlinkUpdate(HyperlinkEvent event) {
				if (Desktop.isDesktopSupported() && event.getEventType() == EventType.ACTIVATED) {
					Desktop desktop = Desktop.getDesktop();
					
					try {
						desktop.browse(event.getURL().toURI());
					} catch (IOException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} catch (URISyntaxException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
			}
		});
    }
    
    // Adds tag information to the set of available apps
    private void addTagInformation() {
    }
    
    private void updateDescriptionBox() {
    	Set<WebApp> selectedApps = getSelectedApps();
    	int numSelected = selectedApps.size();
    	
    	// If no apps are selected, clear the description box
    	if (numSelected == 0) {
            descriptionTextPane.setText("<html> <head> TestHeader </head> <body>" +
            		"<p style=\"margin-top: 0\"> App information is displayed here. </p> </body> </html> ");    
            descriptionTextPane.setText("");
    	// If a single app is selected, show its app description
    	} else if (numSelected == 1) {
    		WebApp selectedApp = selectedApps.iterator().next();
    		
    		String text = "<html><b>" + selectedApp.getFullName() + "</b></html>";
    		text += "\n\n";
    		text += selectedApp.getDescription();
    		
    		text = "";
    		text += "<html> <head> </head> <body>";
    		
    		// App hyperlink to web store page
    		text += "<p style=\"margin-top: 0\"> <a href=\"" + selectedApp.getPageUrl() + "\">" + selectedApp.getPageUrl() + "</a> </p>";
    		
    		// App image
    		// text += "<img border=\"0\" src=\"" + appManager.getWebQuerier().getAppStoreUrl() + selectedApp.getIconUrl() + "\" alt=\"" + selectedApp.getFullName() + "\"/>";
    		
    		// App name
    		text += "<p> <b>" + selectedApp.getFullName() + "</b> </p>";
    		
    		// App description
    		text += "<p>" + selectedApp.getDescription() + "</p>";
    		text += "</body> </html>";
    		descriptionTextPane.setText(text);
    	} else {
    		String text = "<html> <head> </head> <body> <p style=\"margin-top: 0\">";
    		text += numSelected + " apps selected: <br />";
    		
    		for (WebApp webApp : selectedApps) {
    			text += "<br />" + webApp.getFullName();
    		};
    		text += "</p>";
    		text += "</body> </html>";
    		descriptionTextPane.setText(text);
    	}
    }
}
